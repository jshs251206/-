<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>í˜ˆêµ¬ ìë™ ê°œìˆ˜ ì„¸ê¸° (ê°œì„  ë²„ì „)</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      padding: 20px; 
      max-width: 1200px;
      margin: 0 auto;
    }
    .controls {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .control-group {
      margin: 10px 0;
    }
    label {
      display: inline-block;
      width: 180px;
      font-weight: bold;
    }
    input[type="range"] {
      width: 200px;
    }
    canvas { 
      border: 2px solid #333; 
      margin-top: 10px; 
      max-width: 100%;
      display: block;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #result {
      background: #e7f3ff;
      padding: 15px;
      border-radius: 5px;
      margin-top: 10px;
      font-size: 18px;
    }
    #status {
      color: #666;
      font-style: italic;
      padding: 10px;
      background: #fff3cd;
      border-radius: 5px;
      margin: 10px 0;
    }
    .loading {
      color: #007bff;
      font-weight: bold;
    }
  </style>
</head>
<body>
<h2>ğŸ”¬ í˜ˆêµ¬ ìë™ ê°œìˆ˜ ì„¸ê¸° (ê°œì„  ë²„ì „)</h2>

<div class="controls">
  <div class="control-group">
    <input type="file" id="imageInput" accept="image/*">
  </div>
  
  <div class="control-group">
    <label>ìµœì†Œ ë©´ì :</label>
    <input type="range" id="minArea" min="20" max="200" value="50" step="5">
    <span id="minAreaVal">50</span>
  </div>
  
  <div class="control-group">
    <label>ìµœëŒ€ ë©´ì :</label>
    <input type="range" id="maxArea" min="500" max="3000" value="1800" step="100">
    <span id="maxAreaVal">1800</span>
  </div>
  
  <div class="control-group">
    <label>ì›í˜•ë„ ì„ê³„ê°’:</label>
    <input type="range" id="circularity" min="0.3" max="0.9" value="0.5" step="0.05">
    <span id="circularityVal">0.5</span>
  </div>
  
  <div class="control-group">
    <label>ë¸”ëŸ¬ í¬ê¸°:</label>
    <input type="range" id="blurSize" min="3" max="15" value="7" step="2">
    <span id="blurSizeVal">7</span>
  </div>
  
  <div class="control-group">
    <button id="reanalyze" disabled>ë‹¤ì‹œ ë¶„ì„</button>
    <button id="resetParams">íŒŒë¼ë¯¸í„° ì´ˆê¸°í™”</button>
  </div>
</div>

<p id="status">OpenCV ë¡œë”© ì¤‘...</p>
<canvas id="canvas"></canvas>
<h3 id="result"></h3>

<script>
let currentImage = null;
let cvReady = false;

// OpenCV.js ë¡œë”©
function loadOpenCV() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://docs.opencv.org/4.x/opencv.js';
    script.async = true;
    
    script.onload = () => {
      // OpenCVê°€ ì™„ì „íˆ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
      if (typeof cv !== 'undefined') {
        cv['onRuntimeInitialized'] = () => {
          console.log('OpenCV ë¡œë”© ì™„ë£Œ');
          resolve();
        };
      } else {
        const checkCV = setInterval(() => {
          if (typeof cv !== 'undefined') {
            clearInterval(checkCV);
            cv['onRuntimeInitialized'] = () => {
              console.log('OpenCV ë¡œë”© ì™„ë£Œ');
              resolve();
            };
          }
        }, 100);
      }
    };
    
    script.onerror = () => {
      reject(new Error('OpenCV ë¡œë”© ì‹¤íŒ¨'));
    };
    
    document.head.appendChild(script);
  });
}

// ì´ˆê¸°í™”
async function init() {
  try {
    await loadOpenCV();
    cvReady = true;
    document.getElementById('status').innerHTML = 'âœ… OpenCV ë¡œë”© ì™„ë£Œ. ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.';
    document.getElementById('reanalyze').disabled = false;
    setupEventListeners();
  } catch (error) {
    document.getElementById('status').innerHTML = 'âŒ OpenCV ë¡œë”© ì‹¤íŒ¨. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.';
    console.error(error);
  }
}

function setupEventListeners() {
  // íŒŒë¼ë¯¸í„° ë³€ê²½ ì‹œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
  document.getElementById('minArea').addEventListener('input', (e) => {
    document.getElementById('minAreaVal').textContent = e.target.value;
  });
  document.getElementById('maxArea').addEventListener('input', (e) => {
    document.getElementById('maxAreaVal').textContent = e.target.value;
  });
  document.getElementById('circularity').addEventListener('input', (e) => {
    document.getElementById('circularityVal').textContent = e.target.value;
  });
  document.getElementById('blurSize').addEventListener('input', (e) => {
    document.getElementById('blurSizeVal').textContent = e.target.value;
  });

  document.getElementById('resetParams').addEventListener('click', () => {
    document.getElementById('minArea').value = 50;
    document.getElementById('maxArea').value = 1800;
    document.getElementById('circularity').value = 0.5;
    document.getElementById('blurSize').value = 7;
    document.getElementById('minAreaVal').textContent = '50';
    document.getElementById('maxAreaVal').textContent = '1800';
    document.getElementById('circularityVal').textContent = '0.5';
    document.getElementById('blurSizeVal').textContent = '7';
    if (currentImage) analyzeImage();
  });

  document.getElementById('reanalyze').addEventListener('click', () => {
    if (currentImage) analyzeImage();
  });

  const input = document.getElementById("imageInput");
  const img = new Image();
  
  input.addEventListener("change", e => {
    const file = e.target.files[0];
    if (file) {
      document.getElementById('status').innerHTML = 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘...';
      img.src = URL.createObjectURL(file);
    }
  });
  
  img.onload = () => {
    currentImage = img;
    analyzeImage();
  };
  
  img.onerror = () => {
    document.getElementById('status').innerHTML = 'âŒ ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨';
  };
}

function analyzeImage() {
  if (!currentImage || !cvReady) {
    console.log('ì´ë¯¸ì§€ ë˜ëŠ” OpenCVê°€ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ');
    return;
  }
  
  const startTime = performance.now();
  document.getElementById("status").innerHTML = '<span class="loading">ğŸ”„ ë¶„ì„ ì¤‘...</span>';
  
  try {
    const canvas = document.getElementById("canvas");
    const img = currentImage;
    
    // ì´ë¯¸ì§€ í¬ê¸° ìµœì í™”
    let displayWidth = img.width;
    let displayHeight = img.height;
    const maxDim = 1200;
    
    if (img.width > maxDim || img.height > maxDim) {
      const scale = Math.min(maxDim / img.width, maxDim / img.height);
      displayWidth = Math.floor(img.width * scale);
      displayHeight = Math.floor(img.height * scale);
    }
    
    canvas.width = displayWidth;
    canvas.height = displayHeight;
    
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
    
    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let thresh = new cv.Mat();
    let morphed = new cv.Mat();
    
    // íŒŒë¼ë¯¸í„° ê°€ì ¸ì˜¤ê¸°
    const minArea = parseInt(document.getElementById('minArea').value);
    const maxArea = parseInt(document.getElementById('maxArea').value);
    const minCircularity = parseFloat(document.getElementById('circularity').value);
    const blurSize = parseInt(document.getElementById('blurSize').value);
    
    // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    
    // ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬
    cv.GaussianBlur(gray, blur, new cv.Size(blurSize, blurSize), 0);
    
    // ì ì‘í˜• ì„ê³„ê°’
    cv.adaptiveThreshold(
      blur, thresh,
      255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,
      cv.THRESH_BINARY_INV,
      15, 3
    );
    
    // ëª¨í´ë¡œì§€ ì—°ì‚°
    let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
    cv.morphologyEx(thresh, morphed, cv.MORPH_OPEN, kernel);
    cv.morphologyEx(morphed, morphed, cv.MORPH_CLOSE, kernel);
    
    // ê²©ì ê·¸ë¦¬ê¸°
    const rows = 5, cols = 5;
    const cellW = Math.floor(src.cols / cols);
    const cellH = Math.floor(src.rows / rows);
    
    let total = 0;
    
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = c * cellW;
        const y = r * cellH;
        
        const roi = morphed.roi(new cv.Rect(x, y, cellW, cellH));
        
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        
        cv.findContours(
          roi, contours, hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );
        
        let cellCount = 0;
        
        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          
          if (area < minArea || area > maxArea) {
            cnt.delete();
            continue;
          }
          
          const peri = cv.arcLength(cnt, true);
          if (peri === 0) {
            cnt.delete();
            continue;
          }
          
          const circ = 4 * Math.PI * area / (peri * peri);
          
          if (circ < minCircularity) {
            cnt.delete();
            continue;
          }
          
          const m = cv.moments(cnt);
          if (m.m00 !== 0) {
            const cx = Math.round(m.m10 / m.m00) + x;
            const cy = Math.round(m.m01 / m.m00) + y;
            
            cv.circle(src, new cv.Point(cx, cy), 5,
              new cv.Scalar(255, 0, 0, 255), -1);
            
            const radius = Math.sqrt(area / Math.PI);
            cv.circle(src, new cv.Point(cx, cy), Math.round(radius),
              new cv.Scalar(0, 255, 0, 255), 2);
            
            cellCount++;
            total++;
          }
          
          cnt.delete();
        }
        
        roi.delete();
        contours.delete();
        hierarchy.delete();
        
        cv.rectangle(
          src,
          new cv.Point(x, y),
          new cv.Point(x + cellW, y + cellH),
          new cv.Scalar(0, 0, 255, 255),
          2
        );
        
        if (cellCount > 0) {
          cv.putText(
            src,
            cellCount.toString(),
            new cv.Point(x + 5, y + 20),
            cv.FONT_HERSHEY_SIMPLEX,
            0.6,
            new cv.Scalar(255, 255, 0, 255),
            2
          );
        }
      }
    }
    
    cv.imshow(canvas, src);
    
    const endTime = performance.now();
    const processingTime = ((endTime - startTime) / 1000).toFixed(2);
    
    document.getElementById("result").innerHTML = `
      <strong>í˜ˆêµ¬ ê°œìˆ˜ (í‘œì‹œëœ ì¹¸ ê¸°ì¤€): ${total}</strong><br>
      ì²˜ë¦¬ ì‹œê°„: ${processingTime}ì´ˆ<br>
      í‰ê·  ì¹¸ë‹¹ ê°œìˆ˜: ${(total / 25).toFixed(1)}ê°œ
    `;
    document.getElementById("status").innerHTML = 'âœ… ë¶„ì„ ì™„ë£Œ';
    
    // ë©”ëª¨ë¦¬ í•´ì œ
    src.delete();
    gray.delete();
    blur.delete();
    thresh.delete();
    morphed.delete();
    kernel.delete();
    
  } catch (error) {
    console.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', error);
    document.getElementById("status").innerHTML = 'âŒ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message;
  }
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
init();
</script>
</body>
</html>
