<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í˜ˆêµ¬ ìë™ ê³„ìˆ˜ (ì¹¸ ë¶„í•  ë°©ì‹)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    canvas { border: 1px solid #333; margin-top: 10px; max-width: 100%; }
  </style>
</head>

<body>

<h2>ğŸ”¬ í˜ˆêµ¬ ìë™ ê°œìˆ˜ ì„¸ê¸° (ê²©ì ì¹¸ ê¸°ì¤€)</h2>
<input type="file" id="imageInput" accept="image/*">
<p id="status">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.</p>
<canvas id="canvas"></canvas>
<h3 id="result"></h3>

<script>
cv['onRuntimeInitialized'] = () => {

  const input = document.getElementById("imageInput");
  const img = new Image();

  input.addEventListener("change", e => {
    img.src = URL.createObjectURL(e.target.files[0]);
  });

  img.onload = () => {
    const canvas = document.getElementById("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let thresh = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);

    // ğŸ”¹ í˜ˆêµ¬ ê°•ì¡°
    cv.adaptiveThreshold(
      blur, thresh,
      255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,
      cv.THRESH_BINARY_INV,
      11, 2
    );

    // ====== ğŸ”¥ ê²©ì ì¹¸ ROI ìˆ˜ë™ ì •ì˜ ======
    // âš ï¸ ì´ ê°’ì€ í—¤ëª¨ì‚¬ì´í† ë¯¸í„° ì‚¬ì§„ ê¸°ì¤€
    const cols = 5;
    const rows = 5;

    const cellW = Math.floor(src.cols / cols);
    const cellH = Math.floor(src.rows / rows);

    let totalCount = 0;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {

        let x = c * cellW;
        let y = r * cellH;
        let roiRect = new cv.Rect(x, y, cellW, cellH);
        let roi = thresh.roi(roiRect);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        cv.findContours(
          roi, contours, hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );

        for (let i = 0; i < contours.size(); i++) {
          let cnt = contours.get(i);
          let area = cv.contourArea(cnt);
          if (area < 60 || area > 1500) continue;

          let peri = cv.arcLength(cnt, true);
          if (peri === 0) continue;

          let circ = 4 * Math.PI * area / (peri * peri);
          if (circ < 0.6) continue;

          totalCount++;

          // ROI ì¢Œí‘œ â†’ ì „ì²´ ì¢Œí‘œ ë³€í™˜
          let shifted = new cv.Mat();
          cnt.convertTo(shifted, -1, 1, 0);
          for (let j = 0; j < shifted.data32S.length; j += 2) {
            shifted.data32S[j] += x;
            shifted.data32S[j + 1] += y;
          }

          let v = new cv.MatVector();
          v.push_back(shifted);
          cv.drawContours(src, v, -1, new cv.Scalar(255, 0, 0, 255), 2);

          shifted.delete(); v.delete();
        }

        roi.delete(); contours.delete(); hierarchy.delete();

        // ì¹¸ í…Œë‘ë¦¬ í‘œì‹œ
        cv.rectangle(
          src,
          new cv.Point(x, y),
          new cv.Point(x + cellW, y + cellH),
          new cv.Scalar(0, 255, 0, 255),
          1
        );
      }
    }

    cv.imshow(canvas, src);
    document.getElementById("result").innerText =
      `í˜ˆêµ¬ ê°œìˆ˜ (í‘œì‹œëœ ì¹¸ ê¸°ì¤€): ${totalCount}`;
    document.getElementById("status").innerText = "ë¶„ì„ ì™„ë£Œ";

    src.delete(); gray.delete(); blur.delete(); thresh.delete();
  };
};
</script>

</body>
</html>
