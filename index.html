<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í˜ˆêµ¬ ìë™ ê°œìˆ˜ ì„¸ê¸° (ê²©ì ì¹¸ ê¸°ì¤€)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    canvas { border: 1px solid #333; margin-top: 10px; max-width: 100%; }
  </style>
</head>

<body>

<h2>ğŸ”¬ í˜ˆêµ¬ ìë™ ê°œìˆ˜ ì„¸ê¸° (ê²©ì ì¹¸ ê¸°ì¤€)</h2>
<input type="file" id="imageInput" accept="image/*">
<p id="status">ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.</p>
<canvas id="canvas"></canvas>
<h3 id="result"></h3>

<script>
cv['onRuntimeInitialized'] = () => {

  const input = document.getElementById("imageInput");
  const img = new Image();

  input.addEventListener("change", e => {
    img.src = URL.createObjectURL(e.target.files[0]);
  });

  img.onload = () => {
    document.getElementById("status").innerText = "ë¶„ì„ ì¤‘...";

    const canvas = document.getElementById("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let thresh = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);

    cv.adaptiveThreshold(
      blur, thresh,
      255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,
      cv.THRESH_BINARY_INV,
      11, 2
    );

    // ğŸ”¹ ê²©ì ì¹¸ ìˆ˜ (í—¤ëª¨ì‚¬ì´í† ë¯¸í„° ê¸°ì¤€)
    const rows = 5;
    const cols = 5;
    const cellW = Math.floor(src.cols / cols);
    const cellH = Math.floor(src.rows / rows);

    let total = 0;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {

        const x = c * cellW;
        const y = r * cellH;
        const roiRect = new cv.Rect(x, y, cellW, cellH);
        const roi = thresh.roi(roiRect);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        cv.findContours(
          roi, contours, hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );

        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area < 60 || area > 1500) continue;

          const peri = cv.arcLength(cnt, true);
          if (peri === 0) continue;

          const circ = 4 * Math.PI * area / (peri * peri);
          if (circ < 0.6) continue;

          total++;

          // ì¤‘ì‹¬ì  ê³„ì‚° (ROI ê¸°ì¤€)
          const m = cv.moments(cnt);
          if (m.m00 !== 0) {
            const cx = Math.round(m.m10 / m.m00) + x;
            const cy = Math.round(m.m01 / m.m00) + y;
            cv.circle(
              src,
              new cv.Point(cx, cy),
              4,
              new cv.Scalar(255, 0, 0, 255),
              -1
            );
          }
        }

        roi.delete(); contours.delete(); hierarchy.delete();

        // ê²©ì í‘œì‹œ
        cv.rectangle(
          src,
          new cv.Point(x, y),
          new cv.Point(x + cellW, y + cellH),
          new cv.Scalar(0, 255, 0, 255),
          1
        );
      }
    }

    cv.imshow(canvas, src);
    document.getElementById("result").innerText =
      `í˜ˆêµ¬ ê°œìˆ˜ (í‘œì‹œëœ ì¹¸ ê¸°ì¤€): ${total}`;
    document.getElementById("status").innerText = "ë¶„ì„ ì™„ë£Œ";

    src.delete(); gray.delete(); blur.delete(); thresh.delete();
  };
};
</script>

</body>
</html>
